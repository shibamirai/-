# タイムアタック機能を追加する

今度は九九アプリに、10問解き終わるまでのタイムを計測するタイムアタック機能をもたせてみましょう。

そのためには、タイムアタックを開始した時間と今何問目かという情報を、ユーザ（が使っているブラウザ）ごとに覚えておく必要があります。しかし、ブラウザと Web アプリケーションはリクエスト単位で接続されるため、ブラウザから次の問題へのリクエストを送信しても、Web アプリケーションではそれが前の問題と同じブラウザからのものなのか、別のブラウザからのものなのかを判断できません。

それを解決するのがセッションという仕組みです。セッションを開始すると **セッション ID** というランダムな文字列がブラウザのクッキーに保存され、それによって Web アプリケーションはブラウザを識別できるようになります。そのセッションに情報を格納すると、その情報はリクエストをまたいで使用することができるため、ブラウザごとに開始時間と問題番号を覚えておくことができるようになります。

![セッション](img/%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3.png)

## セッションの利用

セッションを利用するには、以下のように HttpServletRequest オブジェクトから HttpSession オブジェクトを取得します。

```java
  HttpSession session = request.getSession();
```

引数なしで getSession メソッドを呼ぶと、まだセッションが開始されていなければ新しく HttpSession オブジェクトが作成され、すでに開始されていればそのオブジェクトが返されます。

セッションに情報を追加したり、その情報を取得したりする方法はリクエスト属性とほぼ同じです。HttpServletRequest オブジェクトに対して setAttribute / getAttribute メソッドを呼んでいたのと同じように、HttpSession オブジェクトに対して setAttribute / getAttribute メソッドを呼んで情報の追加・取得を行います。

```java
  HttpSession session = request.getSession();

  session.setAttribute("foo", "bar");     // セッションに "foo" という名前で文字列 "bar" という値をセット

  String val = (String) session.getAttribute("foo");  // セッションから "foo" 属性の値を文字列として取得
```

セッションに保存した値を JSP で表示する場合もリクエスト属性と同じで、${属性名} と書けばその値に変換されます。JSP はまずリクエストからその属性を探し、見つからなければ次にセッションを探します。リクエストとセッションに同じ名前の属性を登録すると、リクエストの方が使われるので注意してください。

## 問題番号を表示する

それではセッションを使って、最初は問題番号を表示できるようにしましょう。

まずはセッションに、"count" という名前で「１問目」を表す数値 1 をセットします。
実は、リクエストやセッションにセットできる値は参照型（≒何かのクラスのインスタンス）のみで、int や long, boolean といったプリミティブ型はの値はセットできません。[^1]

[^1]:九九の x, y の値をセットするとき ```request.setAttribute("x", x)``` のように int 型の値をそのままセットしていますが、これは Java が暗黙的に int 型のラッパークラスである Integer 型に変換してセットしており、値を取得する時も、Integer → int もしくは Integer → String への型変換が自動で行われています。

ですので、プリミティブ型を参照型として扱える**ラッパークラス**を使って値をセットします。int 型のラッパークラスは Integer 型なので、"count" に 1 をセットする場合は Integer 型の valueOf メソッドを使って以下のように書くことができます。

```java
    session.setAttribute("count", Integer.valueOf(1));
```

これを KukuServlet の doGet メソッドの先頭で行ってください。

続いて JSP 側で、この "count" を使って問題番号を表示します。
九九の問題（と不正解の "x" 印）の上に \<h1\> タグで「第 1 問」と表示させてください。"1" の部分は "count" を使って出力します。
以下のようになれば成功です。

![問題番号表示](img/%E5%95%8F%E9%A1%8C%E7%95%AA%E5%8F%B7%E8%A1%A8%E7%A4%BA.png)

[ここまでのソースコードを確認する](https://github.com/shibamirai/servlet-learning/tree/%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%BF%E3%83%83%E3%82%AF%E6%A9%9F%E8%83%BD%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B1)

---

## 問題番号を更新する

続いて問題番号をカウントアップさせていきます。

問題表示のリクエストが来たら、まず前の問題番号を取得します。セッションから getAttribute メソッドを使って "count" の値を取り出しましょう。Integer 型のオブジェクトをセットしていたので、取り出した値も Integer 型にキャストします。続いて次の問題番号をセットするので、取り出した値を 1 増やしてから再度 "count" としてセットしなおします。

ここで、最初の問題のときは前の問題番号は存在しない、つまり "count" という属性はセットされていないはずなので、getAttribute("count") は null を返します。この時が「１問目」なので、"count" に 1 をセットする処理をここに移動しましょう。

ではカウントアップできるようになったか試してみます。

セッションには有効期限があり、デフォルト設定では30分、もしくはブラウザが閉じられるまでとなっています。ですので動作確認するときは、開いているブラウザをすべて閉じてからアプリケーションを実行しなおしてください。

第１問から始まって、問題を進めるごとに第２問、第３問と問題番号がカウントアップされ、解答を間違えると問題番号と問題はそのままに"x"が出るようになっていれば成功です。

[ここまでのソースコードを確認する](https://github.com/shibamirai/servlet-learning/tree/%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%BF%E3%83%83%E3%82%AF%E6%A9%9F%E8%83%BD%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B2)

---

## タイムを計測する

今度は、10問解き終わるまでのタイムを計測しましょう。
問題開始時の時刻を記録しておき、10問解答後の時刻との差分を取ることでタイムを計測することができます。

まずは「１問目」開始時、つまり getAttribute("count") が null を返すときに現在時刻を取得し、それを開始時刻として "start" という名前でセッションに保存してください。
現在時刻は、System.currentTimeMillis() を使ってミリ秒単位で取得できます。このメソッドの戻り値は long 型なので、セッションに保存するときは int 型のときと同様にラッパークラスを使います。long 型のラッパークラスは Long 型なので、Integer 型でやったのと同じように valueOf() メソッドを使って戻り値を Long 型に変換してセッションに保存してください。

続いて、10問解答後の処理を実装します。10問解答し終えたかどうかは、セッションの count 属性が null でなく 10 と等しいかどうかで判定することができますが、count は Integer 型なので、```count == 10``` のように int 型の数値 10 と直接比較するのではなく ```count.intValue() == 10``` として int 型で取り出した値と比較するようにしてください。[^2]

10問解答後は、まず終了時間として現在時刻を取得します。続いてセッションに保存した開始時刻を取り出し、終了時間との差分を取ってタイムを求めましょう。時間はミリ秒単位になっているので、単位を秒にするために 1000 で割って double 型にしてください。

求めたタイムは、新たに結果のページを用意してそちらに表示します。タイムを "time" という名前でリクエストに保存し、それを result.jsp にフォワードして表示しましょう。result.jsp は kuku.jsp をコピーして作成し、九九の問題の代わりに \<p\>タグで「タイム xx.xxx 秒」と表示できるようにしてください。ついでにその下に「再挑戦」と表示して "/arithmetic/kuku" へのリンクを作成し、もう一度初めから問題を開始できるようにしておきましょう。

![タイム](img/%E3%82%BF%E3%82%A4%E3%83%A0.png)

この状態で実行して再挑戦のリンクを押しても、最初の問題には戻らず同じ画面のままタイムが更新されるだけになっているかと思います。これは、セッションに "count" が 10 のまま残り続けているためです。これを解消するために、result.jsp へフォワードする前にセッションを破棄して、保存されている属性をすべてクリアしておきましょう。

セッションの破棄は HttpSession オブジェクトの invalidate() メソッドで行います。

```java
    session.invalidate();
```

これを追加すると、再挑戦のリンクからまた第一問に戻ることができるようになります。

以上で九九アプリの完成です。

[ここまでのソースコードを確認する](https://github.com/shibamirai/servlet-learning/tree/%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%A2%E3%82%BF%E3%83%83%E3%82%AF%E6%A9%9F%E8%83%BD%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B3)

---

## 終わりに

サーブレット入門シリーズはこれで終了です。ですが先の九九アプリは、入力値のバリデーション（値が正しいかどうかのチェック。入力値が存在するか、数値以外が入力されていないかなど）を行っていないなどアプリケーションとしてはまだまだ不完全ですし、もっと色んな機能を追加することもできます。以下にアプリの改善点の例を挙げていますので、余裕がある人はこれらにも挑戦してください。

- 解答の入力値 "z" のバリデーションを行う。不正な値であれば同じ問題画面に戻る
- 最速タイムをファイルに残す。記録更新時にユーザに名前を入力させ、名前と記録をファイルに記録する
- 九九だけでなく、２桁のたし算など他の計算練習ができるページを追加する

[^2]:実際にはオートボクシング/オートアンボクシングという自動変換の仕組みによって、直接 count == 10 と比較することは可能です。しかし、Integer 型同士を比較する場合の == は違う意味を持つ（値の比較ではない）ため、int 型で比較していることをあえて明示するようにしています。
